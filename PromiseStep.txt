Promise 五部曲

1.并发

Task A
step1
step2
step3
step4

Task B
step1
step2

事实上Task A和Task B是可以"同时"运行的，通过穿插地执行它们的每个原子操作，这叫做并发，换句话说，Task A和Task B是并发的。

我们很容易就会把并发和并行弄混。在真正并行的系统中，你会有多个线程，可能一个线程执行Task A同时另一个线程执行Task B。这也意味着，A:1的运行不会阻塞B:1的运行。


2.回调  
控制权转换问题

实际上，这里真正的问题是由于回调引起的控制转移。
在你的程序的前半部分，你控制着程序的进程。现在你转移了控制权，someAsyncThing(..)控制了你剩余程序什么时候返回以及是否返回。
控制转移表明了你的代码和其他人的代码之间的过度信任关系。


类似于快餐业务:
想想上面调用someAsyncThing(..)的例子。如果你可以调用它然后订阅一个事件，当这个调用完成的时候你会得到通知而不是传递一个回调给它，这样难道不会更好吗？
例如，想象这样的代码：

var listener = someAsyncThing(..) ;
listener.on("completion",function(data){
    //keep going now !
}) ;
实际上，如果我们还可以监听调用失败的事件那就更好了。

listener.on("failure",function(){
    //Oops,What's plan B?
}) ;
现在，对于我们调用的每个函数，我们能够在函数成功执行或者失败的时候得到通知。换句话说，每个函数调用会是流程控制图上的决策点。






